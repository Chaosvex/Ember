/*
 * Copyright (c) {{year}} Ember
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

/* 
 * This file was automatically generated by the rpcgen tool.
 * Rather than making changes here, you should consider updating the
 * generator's templates and rerunning.
 */

#include "{{fbs_name}}_generated.h"

#include <spark/Common.h>
#include <spark/Server.h>
#include <spark/Handler.h>
#include <spark/Link.h>
#include <spark/Message.h>
#include <boost/uuid/uuid_generators.hpp>
#include <boost/uuid/uuid_io.hpp>
#include <format>
#include <functional>

namespace ember::services {

class {{name}}Client : public spark::Handler {
	spark::Server& spark_;
	boost::uuids::uuid uuid_;

	flatbuffers::FlatBufferBuilder serialise(auto& msg) const {
		flatbuffers::FlatBufferBuilder fbb;

		// serialise message
		rpc::{{name}}::EnvelopeT env;
		env.message.Set(msg);
		const auto packed = rpc::{{name}}::Envelope::Pack(fbb, &env);
		fbb.Finish(packed);
		return fbb;
	}

protected:
	template<typename T>
	bool send(auto& msg, const spark::Link& link, auto&& cb) const {
		auto channel = link.channel.lock();

		if(!channel) {
			cb(link, std::unexpected(spark::Result::LINK_GONE));
			return false;
		}

		spark::TrackedState state = [cb = std::move(cb)](
			const spark::Link& link, spark::MessageResult result) {
			if(!result) {
				cb(link, std::unexpected(result.error()));
				return;
			}

			auto fb = rpc::{{name}}::Get{{root}}(result->data());
			flatbuffers::Verifier verifier(result->data(), result->size());

			// todo, need to check whether the message is actually the correct type
			const auto msg = static_cast<const T*>(fb->message());

			if(!msg->Verify(verifier)) {
				return;
			}

			cb(link, msg);
		};

		auto fbb = serialise(msg);
		return channel->send(std::move(fbb), std::move(state));
	}

	bool send(auto& msg, const spark::Link& link) const {
		auto channel = link.channel.lock();

		if(channel) {
			auto fbb = serialise(msg);
			return channel->send(std::move(fbb));
		} else {
			return false;
		}
	}

	void connect(std::string host, std::uint16_t port) {
		spark_.connect(host, port, type(), this);
	}

public:
	{{name}}Client(spark::Server& spark)
		: spark_(spark),
		  uuid_(boost::uuids::random_generator()()) {}

	std::string name() override {
		return std::format("{{name}}Client:{}", boost::uuids::to_string(uuid_));
	}

	std::string type() override {
		return "{{name}}";
	}

	void on_message(
		const spark::Link& link,
		const std::span<const std::uint8_t> msg,
		const spark::Token& token = {}) override {
		auto fb = rpc::{{name}}::Get{{root}}(msg.data());
		flatbuffers::Verifier verifier(msg.data(), msg.size());

		switch(fb->message_type()) {
## for handler in handlers
			case rpc::{{name}}::Message::{{handler.response}}:
				dispatch_{{handler.response_sn}}(verifier, *fb->message_as_{{handler.response}}(), link);
				break;
## endfor
		}
	}

## for handler in handlers
	void dispatch_{{handler.response_sn}}(
		flatbuffers::Verifier& verifier,
		const rpc::{{name}}::{{handler.response}}& msg,
		const spark::Link& link) {
		if(!msg.Verify(verifier)) {
			return;
		}

		handle_{{handler.name}}_response(link, msg);
	}
## endfor

## for handler in handlers
	virtual void handle_{{handler.name}}_response(
		const spark::Link& link,
		const {{handler.response_ns}}& msg) {}

## endfor

	void connect_failed(std::string_view ip, std::uint16_t port) override {}
};

} // services, ember